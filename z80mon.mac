	TITLE Z-80A MONITOR V1.2
	.Z80

; COPYRIGHT 1981 MULTIFLEX TECH, INC.

	; KEY CODES

GO	EQU	10H
EM	EQU	11H
EP	EQU	12H
ER	EQU	13H
MV	EQU	14H
SI	EQU	15H
LD	EQU	16H
BP	EQU	17H
SV	EQU	18H
ESC	EQU	19H
PGM	EQU	1AH
CMP	EQU	1BH
OFT	EQU	1CH
EIO	EQU	1DH

	; CHAR CODES

ULINE	EQU	10H
BLANK	EQU	11H
ERR	EQU	12H
CHRH	EQU	13H
CHRL	EQU	14H
CHRP	EQU	15H
APOSTR	EQU	16H
CHRX	EQU	17H
CHRY	EQU	18H
CHRR	EQU	19H
BPDLY	EQU	1AH
EQUALS	EQU	1BH

	; RST / NMI LOCATIONS

RST8V	EQU	0008H
NMIV	EQU	0066H

	; MONITOR REGISTERS

LSEG	EQU	00F8H	; LED DISPLAY SEGMENTS
MLED	EQU	00F9H	; DISP DIGIT SELECT
MKB	EQU	00F9H	; KEYBOARD CODE
PGAL	EQU	00FAH	; EPROM PROGRAMMER ACCESS
PGAH	EQU	00FBH
PGD	EQU	00FCH	; PROGRAMMER DATA

STKB	EQU	03A0H	; STACK BASE
DEVICE	EQU	03A8H	; MONITOR RAM LOCATIONS
ENDADD	EQU	03AAH
STADDR	EQU	03ACH
DSTADD	EQU	03AEH
BYTCNT	EQU	03B0H
CTF	EQU	03B4H	; CONTIN FLG
ERSC	EQU	03B5H	; REG SEL CODE
SSPL	EQU	03B6H	; SAVED SP
SRR	EQU	03B8H
SVI	EQU	03B9H
ESREG	EQU	03BAH	; END OF SAVED REG AREA
SREG	EQU	03CEH	; START OF SAVED REG AREA
SPCL	EQU	03CEH	; SAVED SP
SPCH	EQU	03CFH
BPBA	EQU	03D0H	; BRK-PT'S TBL BASE ADDR

MDB0	EQU	03F0H	; A0	LED DISPLAY
MDB1	EQU	03F1H	; A1	      BUFFER
MDB2	EQU	03F2H	; A2
MDB3	EQU	03F3H	; A3 (MSD)
MDB4	EQU	03F4H	; D0
MDB5	EQU	03F5H	; D1 (MSD)
BPN	EQU	03F6H	; BRK-PT INTR FLG
SCA	EQU	03F7H	; SAVED CURRENT ADDR
BPF	EQU	03F9H	; BRK-PT'S-ACTIVE FLG
CBPNM	EQU	03FAH	; CUR BRK-PT NUM
PRE	EQU	03FBH	; PRE-AMBLE SYNC BYTE
SAL	EQU	03FCH	; SAVED CASSETTE START ADDR
BCL	EQU	03FEH	; SAVED BYTE CNT

	.PHASE	0F000H

ST:
	LD	HL,STKB
	XOR	A
	LD	B,50H
	LD	SP,HL		; INITIALIZE STACK
ST1:
	LD	(HL),A		; CLR MON DATA LOC'S
	INC	HL
	DJNZ	ST1
CTST:
	CALL	CLDSP		; CLR DISP BUF
	LD	A,ULINE		; DISP UNDERBAR PROMPT
	LD	(MDB3),A	; IN A3 DISP
CTST1:
	CALL	GETAD		; GET ADDR & CMD FROM KBD
	CP	ESC
	JR	Z,CTST		; BACK TO CMD PROMPT
	LD	B,A		; SAVE CMD, TEMP
	LD	A,C
	OR	A		; CHK IF ADDR PRESENT
	LD	A,B
	JR	NZ,SA1		; IS ADDR PRESENT ?
	CP	BP		; NO: CHK FOR GP 1 CMDS
	JP	Z,STBP		; DEFINE BREAK-POINTS
	CP	GO
	JP	Z,CTCON		; CONTIN PROG EXECUTION
	CP	PGM
	JP	Z,RDPGM		; READ FROM PGM SOCKET
	CP	SI
	JP	Z,CTSI		; EXEC NEXT SINGLE INSTR
	CP	ER
	JP	Z,STER		; EXAM REG'S AGAIN
	CP	EM
	JP	Z,CTEM		; EXAM CURRENT MEM LOC
	CP	LD
	JP	Z,LDCT		; LOAD INTO MEM FROM CASSETTE
	CP	EIO
	JP	Z,STEIO		; EXAM I/O PORTS
CDER:
	LD	A,ERR
	LD	(MDB3),A	; DISP TRIPLE-BAR FOR ILLEG CMD
	JR	CTST1

SA1:
	CP	SV		; CHK FOR OP 2 CMDS
	JP	Z,STSV		; SAVE MEM BLOCK ONTO CASSETTE
	CP	SI
	JP	Z,STSI		; EXEC A SPEC'D SINGLE INSTR
	CP	MV
	JP	Z,STMV		; MOVE A BLOCK IN MEM
	CP	PGM
	JP	Z,STPGM		; PROGRAM AN EPROM
	CP	GO
	JP	Z,START		; START EXEC OF A PROG
	CP	CMP
	JP	Z,STCMP		; COMPARE 2 BLOCKS IN MEM
	CP	EM
	JP	Z,STEM		; EXAM A SPEC'D MEM LOC
	CP	OFT
	JP	Z,STOFT		; CALC A BR OFFSET
	CALL	CLDSP
	JR	CDER		; ILLEG CMD

	; ROUTINE TO REFRESH LED DISP & SCAN KBD
	
DISP:
	EXX
DS1:
	LD	D,0
	LD	C,1		; LED DIGIT & KBD ROW SEL
	LD	IX,MDB0		; LED DISP BUF PTR
DS2:
	LD	A,C
	OUT	(MLED),A	; SEL LED DISP DIGIT
	LD	E,(IX+0)	; GET DIGIT FROM BUF
	LD	HL,LSGTB
	ADD	HL,DE		; INDEX INTO LED SEG TBL
	LD	A,(HL)
	OUT	(LSEG),A	; DISP THE DIGIT
	LD	A,255
DS3:
	DEC	A
	JR	NZ,DS3		; 1 MS DELAY
	LD	A,01111111B
	OUT	(LSEG),A	; BLANK THE DISPLAY
	IN	A,(MKB)		; RD KBD COL'S
	OR	A
	JR	NZ,DS4		; IS KEY PRESSED ?
	INC	IX		; NO: SEL NEXT DIGIT IN BUF
	RLC	C		; SEL NEXT LED DIGIT
	LD	A,C
	AND	01000000B
	JR	Z,DS2		; MORE DIGITS ?
	JR	DS1		; NO: START OVER AGAIN

DS4:
	CALL	KBDB		; KBD DEBOUNCE DELAY
	LD	D,A		; GET KBD COL POSITION
	JR	Z,DS1		; FALSE ALARM?
	LD	E,C
	CALL	KEYCT		; NO: CALC ROW NUM
	LD	A,B
	RLCA			; MULT BY 8
	RLCA
	RLCA
	LD	E,D
	CALL	KEYCT		; CALC COL NUM
	ADD	A,B		; COMBINE TO FORM KEY CODE
	LD	E,A		; TABLE INDEX
	LD	D,0
	LD	HL,KEYCD	; KEY CODE TBL BASE
	ADD	HL,DE
DS5:
	IN	A,(MKB)		; RD KBD
	OR	A
	JR	NZ,DS5		; WAIT FOR KEY TO BE REL'D
DS6:
	CALL	KBDB		; KBD DEBOUNCE DELAY
	JR	NZ,DS6		; KEY STILL PRESSED ?
	LD	A,(HL)		; NO: GET KEY CODE FROM TBL
	EXX
	RET			; RET KEY CODE IN A

	; ROUTINE TO CLEAR LED DISP
CLDSP:
	LD	A,BLANK		; BLANK CHAR
	LD	B,6
	LD	HL,MDB0		; START WITH FIRST DIGIT
CLD1:
	LD	(HL),A		; FILL IT WITH BLANK
	INC	HL
	DJNZ	CLD1		; SAME FOR REST OF DIGITS
	RET

	; ROUTINE TO CALC A NUM FROM A BIT POSITION
	
KEYCT:
	LD	B,0
KYC1:
	SRL	E		; GET NEXT BIT
	RET	Z		; A '1' BIT? RET NUM IN B
	INC	B		; NO: COUNT THIS BIT POSITION
	JR	KYC1

	; ROUTINE TO GENERATE KBD DEBOUNCE DELAY
	
KBDB:
	LD	A,255
KDB1:
	LD	D,18
KDB2:
	DEC	D
	JR	NZ,KDB2
	DEC	A
	JR	NZ,KDB1		; 20 MS DELAY
	IN	A,(MKB)		; RD KBD
	OR	A
	RET			; RET KBD COL POST IN A, & Z FLAG

	; ROUTINE TO GET ADDR & CMD FROM KBD
	
GETAD:
	LD	HL,MDB3		; SET BUF PTR TO ADDR MSG
	LD	B,4		; ONLY 4 ADDR DIGITS ALLOWED
	LD	C,0		; NO-ADDR IND (OP 1 CMDS)
	CALL	DISP		; REFRESH DISP & SCAN KBD
	CP	GO		; FIRST CMD KEY CODE ABOVE HEX DIG'S
	RET	P		; KEY CODE > 0Fh ? RET CMD IN A
	INC	C		; NO: GOT ADDR MSD: GET IND FOR OP 2 CMD
GETA3:
	LD	(HL),A		; PUT DIGIT IN BUF
	DEC	HL
	DEC	B
	JR	Z,GETA1		; 4TH DIGIT ? GO LOOK FOR CMD
GETA2:
	CALL	DISP		; NO: DISP IT & LOOK FOR MORE
	CP	ESC
	RET	Z		; RET ESC KEY CODE IN A
	CP	GO
	JP	P,GETA2		; CMD KEY ? IGNORE & LOOK AGAIN
	JR	GETA3		; NO: DIGIT KEY

GETA1:
	CALL	DISP		; DISP & SCAN KBD
	CP	GO
	RET	P		; CMD KEY ? RET CMD CODE IN A
	JR	GETA1		; NO: IGNORE & LOOK AGAIN

	; ROUTINE TO TRANSLATE & ASSEMBLE ADDR FROM DISP BUF INTO A NUM
	
ADTR:
	LD	HL,MDB3		; SET BUF PTR TO ADDR MSD
	LD	A,(HL)
	DEC	HL
	ADD	A,A		; SHIFT MSD 4 LEFT
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	(HL)		; INSERT 2ND MSD
	LD	D,A		; SAVE ADDR HI-BYTE
	DEC	HL
	LD	A,(HL)
	DEC	HL
	ADD	A,A		; SHIFT 3RD MSD 4 LEFT
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	(HL)		; INSERT LSD
	LD	E,A		; SAVE ADDR LO-BYTE
	RET			; RET ADDR IN DE

	; ROUTINE TO EXAM & MODIFY SPECIFIED MEM LOCATION

STEM:
	CALL	ADTR		; ASSEMBLE THE ADDR
	LD	(SCA),DE	; SACE IT AS CURRENT ADDR
	LD	A,(DE)		; GET DATA FROM THIS MEM LOC
	LD	B,A
	AND	0FH		; GET LOW HEX DIGIT
	LD	HL,MDB4		; SET DISP BUF TO DATA LSD
	LD	(HL),A		; PUT THE DIGIT INTO BUF
	INC	HL		; POINT TO MSD
	SRL	B		; SHIFT 4 RIGHT TO GET MSD
	SRL	B
	SRL	B
	SRL	B
	LD	(HL),B		; PUT IT IN BUF
	CALL	DISP		; DISP & SCAN KBD
	CP	GO
	JP	P,EMOP		; CMD CODE ?
	LD	(HL),A		; NO: PUT NEW DATA MSD INTO BUF
	ADD	A,A		; SHIFT IT 4 LEFT
	ADD	A,A
	ADD	A,A
	ADD	A,A
	DEC	HL		; POINT TO LSD
	LD	B,A		; SAVE SHIFTED MSD
EM1:
	CALL	DISP		; DISP & SCAN KBD
	CP	GO
	JP	P,EMESC		; CMD CODE ?
	LD	(HL),A		; NO: PUT NEW DATA LSD INTO BUF
	OR	B		; COMBINE IT WITH MSD
	LD	(DE),A		; PUT DATA BYTE INTO ADDR'D MEM LOC
	JR	STEM		; GO BACK TO RD & DISP THAT LOC AGAIN

EMESC:
	CP	ESC
	JR	Z,STEM		; CMD IS ESC ? IGNORE & REPEAT
	JR	EM1		; NO: IGNORE & LOOK FOR ANOTHER

EMOP:
	CP	ESC
	JP	Z,CTST		; CMD IS ESC ? ABORT & BACK TO CMD PROMPT
	CP	EM
	JR	Z,EM2		; NO: CMD IS EM?  EXAM NEXT MEM LOC
	CP	EP
	JR	Z,EM4		; NO: CMD IS EP?  EXAM PREV MEM LOC
	JR	STEM		; NO: IGNORE & REPEAT

EM2:
	LD	HL,MDB0		; POINT TO ADDR LSD
	LD	A,0FH
EM3:
	INC	(HL)		; INCR THE ADDR DIGIT
	CP	(HL)
	JP	P,STEM		; NO OVFLO ? REPEAT THE ROUTINE
	LD	(HL),0		; OVFLO: SET DIGIT TO 0
	INC	HL
	JR	EM3		; GO INCR MSD

EM4:
	LD	HL,MDB0		; POINT TO ADDR LSD
EM5:
	DEC	(HL)		; DECR THE DIGIT
	JP	P,STEM		; NON-O ?  REPEAT
	LD	(HL),0FH	; IS 0: SET DIGIT TO 0FH
	INC	HL
	JR	EM5		; GO DECR MSD

	; ROUTINE TO DIS-ASSEMBLE ADDR FROM NUM INTO DISP BUF

ADIS:
	PUSH	DE		; ADDR IS IN DE, SAVE IT ON STACK
	PUSH	HL		; SAVE REG
	LD	A,E
	AND	0FH		; GET ADDR LSD
	LD	HL,MDB0		; SET BUF PTR TO LSD
	LD	(HL),A		; PUT LSD INTO BUF
	INC	HL
	SRL	E		; GET 2ND DIGIT
	SRL	E
	SRL	E
	SRL	E
	LD	(HL),E		; PUT IT INTO BUF
	INC	HL
	LD	A,D
	AND	0FH		; GET 3RD DIGIT
	LD	(HL),A		; INTO BUF
	INC	HL
	SRL	D		; GET MSD
	SRL	D
	SRL	D
	SRL	D
	LD	(HL),D		; INTO BUF
	POP	HL		; RESTORE REG
	POP	DE		; RESTORE ADDR IN DE
	RET

	; ROUTINE TO DIS-ASSEMBLE DATA FROM NUM INTO DISP BUF

DDIS:
	PUSH	HL		; SAVE REG'S
	PUSH	BC
	LD	A,(DE)		; ADDR IS IN DE, GET CORRESP DATA
	LD	B,A
	AND	0FH		; GET DATA LSD
	LD	HL,MDB4		; SET BUT PTR TO DATA LSD
	LD	(HL),A		; PUT LSD INTO BUF
	INC	HL
	SRL	B		; GET MSD
	SRL	B
	SRL	B
	SRL	B
	LD	(HL),B		; PUT IT INTO BUF
	POP	BC
	POP	HL		; RESTORE REG'S
	RET

	; ROUTINE TO READ EPROM SOCKET

RDPGM:
	LD	DE,MDB5		; TO DISP PROMPT IN DATA MSD
	CALL	ADCOM		; DECODE NEXT KEY CMD
	CP	ESC
	JP	Z,CTST		; IF ESC, BACK TO CMD PROMPT
	CALL	ADTR		; ASSEMBLE DEST'N ADDR
	LD	(DSTADD),DE	; SAVE IT
	LD	DE,MDB4		; TO DISP PROMPT IN DATA LSD
	CALL	ADCOM		; DECODE NEXT KEY CMD & GET DEV NUM
	CP	ESC		; IF ESC, GO BACK TO PREV
	JP	Z,RDPGM		; (DEST ADDR) LEVEL
	CALL	ADTR		; ASSEMBLE DEV NUM
	LD	(DEVICE),DE	; SAVE IT
	LD	A,E		; BEGIN TO DECODE DEV NUM
	CP	8		; IF LAST BYTE OF DEV NUM IS 8,
	JP	NZ,RPG1
	LD	A,D
	CP	27H		; CHK FOR 2708
	JP	Z,R2708
	CALL	CLDSP		; ILLEG DEV NUM: CLR DISP
	JP	CDER		; DISP TRIPLE-BAR ERR IND

RPG1:
	CP	16H		; CHK FOR 2716
	JP	NZ,RPG2
	LD	A,D
	CP	27H
	JP	Z,R2716
	CALL	CLDSP		; ILLEG DEV NUM
	JP	CDER

RPG2:
	CP	32H		; CHK FOR 2732
	CALL	NZ,CLDSP	; ILLG DEV NUM
	JP	NZ,CDER
	LD	A,D
	CP	27H
	JP	Z,R2732
	CP	25H		; CHK FOR 2532
	JP	Z,R2732		; SAVE ROUTINE FOR 2532 AND 2732
	CALL	CLDSP		; ILLEG DEV NUM
	JP	CDER

R2708:
	LD	B,4		; NUM OF 256-BYTE PAGES TO RD
	JR	READ

R2716:
	LD	B,8
	JR	READ

R2732:
	LD	B,16
READ:
	LD	HL,(DSTADD)	; GET SAVED DEST ADDR
	XOR	A		; CLR A
	LD	E,A		; CLR DE
	LD	D,A
RPG4:
	OUT	(PGAH),A	; SET EPROM ADDR
RPG5:
	LD	A,E
	OUT	(PGAL),A
	IN	A,(PGD)		; RD EPROM DATA
	LD	(HL),A		; STORE IN MEM
	INC	HL
	INC	E		; NEXT BYTE
	JR	NZ,RPG5
	INC	D
	LD	A,D
	CP	B		; CHK FOR LAST BYTE
	JR	NZ,RPG4
	LD	DE,(DSTADD)	; GET DEST ADDR
	CALL	ADIS		; DIS-ASSEMBLE IT
	JP	STEM		; GO EXAMINE IT

	; ROUTINE TO COMPARE 2 BLOCKS OF MEM

STCMP:
	CALL	ADTR		; ASSEMBLE STARTING ADDR
	PUSH	DE		; SAVE IT
CMP1:
	LD	DE,MDB5		; TO DISP PROMPT IN DATA MSG
	CALL	ADCOM		; DECODE NEXT KEY CMD
	CP	ESC
	JR	NZ,CMP2
	POP	DE		; IF ESC, RESTORE STACK
	JP	CTST		; GO BACK TO CMD PROMPT

CMP2:
	CALL	ADTR		; ASSEMBLE ENDING ADDR
	PUSH	DE
	LD	DE,MDB4		; TO DISP PROMPT IN DATA LSD
	CALL	ADCOM		; DECODE NEXT CMD KEY
	CP	ESC
	JR	NZ,CMP3
	POP	DE		; IF ESC, GO BACK TO PREV
	JR	CMP1		; (ST ADDR) LEVEL

CMP3:
	CALL	ADTR		; ASSEMBLE DEST ADDR (2ND BLK)
	POP	HL		; END ADDR
	POP	BC		; START ADDR
	OR	A
	SBC	HL,BC		; BYTE CNT
	LD	B,H
	LD	C,L
	DEC	SP
	DEC	SP
	POP	HL		; START ADDR
	INC	BC
CMP4:
	LD	A,(DE)		; DATA FROM 2ND BLK
	CP	(HL)		; DATA FROM 1ST BLK
	CALL	NZ,MISM		; IF MISMATCH
	INC	HL
	INC	DE		; ON TO NEXT PAIR OF BYTES
	DEC	C
	JR	NZ,CMP4		; IF MORE DATA
	DEC	B
	JR	NZ,CMP4
	JP	MTD		; BLK'S MATCH: DISP DOUBLE PROMPT

	; ROUTINE TO DISP MIS-MATCH LOC'S

MISM:
	CALL	ADIS		; DIS-ASSEMBLE ADDR INTO DISP BUF
	CALL	DDIS		; DIS-ASSEMBLE DATA
MSM1:
	CALL	DISP		; DISP THEM
	CP	EM		; EM KEY ?
	JR	Z,MISM		; YES:  DISP 2ND BLK DATA
	CP	EP		; EP KEY ?
	JR	Z,MSM3		; YES:  DISP 1ST BLK DATA
	CP	GO		; GO KEY ?
	RET	Z		; GO GET NEXT MISMATCH PAIR
	CP	ESC		; ESC KEY ?
	JR	Z,MSM2		; ABORT
	JR	MSM1		; IGNORE ALL OTHER KEYS

MSM2:
	POP	BC
	JP	CTST		; BACK TO CMD PROMPT

MSM3:
	EX	DE,HL
	CALL	ADIS		; DIS-ASSEMBLE 1ST BLK ADDR
	CALL	DDIS		; & DATA
	EX	DE,HL
	JR	MSM1		; GO DISP THEM

	; ROUTINE TO RE-EXAM LAST MEM LOC

CTEM:
	LD	DE,(SCA)	; GET SAVED ADDR
	CALL	ADIS		; DIS-ASSEMBLE IT
	JP	STEM		; GO EXAMINE IT

	; ROUTINE TO GET ADDR & DECODE CMD FROM KBD

ADCOM:
	CALL	CLDSP		; CLR DISP BUF
	LD	A,ULINE		; TO DISP PROMPT IN DIGIT
	LD	(DE),A		; SPEC'D BY DE
	CALL	GETAD		; GET ADDR & CMD FROM KBD
	LD	B,A		; SAVE THIS CMD
	LD	A,C		; GET 'DIGIT-ENTERED' CODE
	OR	A
	LD	A,B		; CMD
	JR	NZ,ADC1		; DIGIT ENTERED ?
	CP	ESC		; NO: IF ESC, RET TO PREV LEVEL
	RET	Z
	JR	ADCOM		; IGNORE OTHER CMD'S

ADC1:
	CP	ESC
	JR	Z,ADCOM		; IF ESC, RESTART THIS LEVEL
ADC2:
	CP	GO
	RET	Z		; IF GO, RET (DIGITS IN BUF)
	CALL	GETA1		; IF OTHER CMD, IGNORE & WAIT
	JR	ADC2		; FOR ANOTHER

	; ROUTINE TO MOVE A MEM BLK TO ANOTHER POS

STMV:
	CALL	ADTR		; ASSEMBLE START ADDR
	PUSH	DE		; SAVE IT
	PUSH	DE
MV1:
	LD	DE,MDB5		; TO DISP PROMPT IN DATA MSD
	CALL	ADCOM		; DECODE NEXT KEY CMD
	CP	ESC
	JR	NZ,MV2
	POP	DE		; IF ESC, RESTORE STACK & GO
	POP	DE		; BACK TO CMD PROMPT
	JP	CTST

MV2:
	CALL	ADTR		; ASSEMBLE END ADDR
	PUSH	DE
	LD	DE,MDB4		; TO DISP PROMPT IN DATA LSD
	CALL	ADCOM		; DECODE NEXT KEY CMD
	CP	ESC
	JR	NZ,MV3
	POP	DE		; IF ESC, BACK TO CMD PROMPT
	JR	MV1

MV3:
	CALL	ADTR		; ASSEMBLE DEST ADDR
	POP	HL		; END ADDR
	POP	BC		; START ADDR
	INC	SP
	INC	SP
	PUSH	DE		; DEST ADDR
	OR	A
	SBC	HL,BC		; BYTE CNT
	LD	B,H
	LD	C,L
	DEC	SP
	DEC	SP
	POP	HL		; STAR ADDR
	OR	A
	SBC	HL,DE		; IS START ADDR < DEST ADDR ?
	JR	C,MV4		; NO
	DEC	SP
	DEC	SP
	POP	HL		; START ADDR
	INC	BC
	LDIR			; BLK MOVE DOWN, BOTTOM BYTE 1ST
	JR	MV5

MV4:
	EX	DE,HL
	ADD	HL,BC		; DEST ADDR + BYTE CNT
	EX	DE,HL
	DEC	SP
	DEC	SP
	POP	HL		; START ADDR
	ADD	HL,BC		; START ADDR + BYTE CNT
	INC	BC		; IE, TOP OF BLK
	LDDR			; BLK MOVE UP, TOP BYTE 1ST
MV5:
	POP	DE		; DEST ADDR
	CALL	ADIS		; DIS-ASSEMBLE IT
	JP	STEM		; GO EXAM IT

	; ROUTINE TO CALC BR INSTR OFFSETS

STOFT:
	CALL	ADTR		; ASSEMBLE START ADDR
	PUSH	DE		; SAVE IT
	LD	DE,MDB5
	CALL	ADCOM
	CP	ESC
	JR	NZ,OFT4		; IF ESC, BACK TO CMD PROMPT
	POP	DE
	JP	CTST

OFT4:
	CALL	ADTR		; ASSEMBLE DEST ADDR
	CALL	CLDSP
	LD	H,D
	LD	L,E
	POP	BC		; START ADDR
	OR	A
	SBC	HL,BC		; DIFFERENCE BYTE CNT
	LD	BC,2
	OR	A
	SBC	HL,BC		; SUBT 2
	LD	A,H
	JP	P,OFT1
	CP	0FFH
	JR	NZ,OFER		; OUT OF RANGE?
	LD	A,L
	OR	A
	JP	P,OFER
OFT2:
	LD	A,L
	LD	B,A
	AND	0FH		; GET OFFSET LSD
	LD	HL,MDB4		; INTO DATA DISP BUF
	LD	(HL),A		; LSD
	INC	HL
	SRL	B		; GET MSD
	SRL	B
	SRL	B
	SRL	B
	LD	(HL),B		; DATA BUF MSD
OFT3:
	CALL	DISP		; DISP IT
	CP	ESC
	JR	NZ,OFT3		; WAIT FOR ESC KEY
	JP	CTST

OFT1:
	CP	0
	JR	NZ,OFER		; OUT OF RANGE ?
	LD	A,L
	OR	A
	JP	P,OFT2
OFER:
	LD	A,ERR		; DISPLAY TRIPLE BAR ERR IND
	LD	(MDB5),A
	JP	CTST1

	; ROUTINE TO PROGRAM EPROMS

STPGM:
	CALL	ADTR		; TRANSLATE THE ADDRESS INTO HEX AND
	LD	(STADDR),DE	; STPRE IT AS THE STARTING ADDRESS
PGM1:
	LD	DE,MDB5		; MOVE THE UNDERSCORE TO THE MS DATA
	CALL	ADCOM		; DIGIT AND WAIT FOR A CMD KEY
	CP	ESC
	JP	Z,CTST		; IF IT WASN'T ESC IT MUST BE GO
	CALL	ADTR		; TRANSLATE THE ADDRESS INTO HEX AND
	LD	(ENDADD),DE	; STORE IT AS THE ENDING ADDRESS
PGM2:
	LD	DE,MDB4		; MOVE THE UNDERSCORE TO THE LS
	CALL	ADCOM		; DATA DIGIT AND WAIT FOR A CMD KEY
	CP	ESC		; IF ESC WAS PRESSED GO BACK TO THE
	JR	Z,PGM1		; PREVIOUS COMMAND LEVEL
	CALL	ADTR		; IF ESC WASN'T PRESSED GET THE ADDR
	LD	(DSTADD),DE	; IN THE DISPLAY AND STORE IT IN
	LD	DE,MDB4		; DESTINATION ADDRESS
	CALL	ADCOM		; WAIT FOR DEV NUM TO BE ENTERED
	CP	ESC		; FOLLOWED BY A <GO> OR IF <ESC> IS
	JR	Z,PGM2		; PRESSED GO BACK TO THE PREVIOUS
	CALL	ADTR		; COMMAND LEVEL
	LD	(DEVICE),DE
;
; THIS NEXT SECTION CALCULATES THE TOTAL NUMBER OF BYTES TO
; BE PROGRAMMED AND MAKES SURE IT IS POSITIVE, IE, THE USER
; ENTERED THE STARTING ADDRESS BEFORE ENTERING THE ENDING
; ADDRESS.
;
	LD	HL,(ENDADD)
	LD	BC,(STADDR)
	OR	A		; CLEAR CARRY FLAG
	SBC	HL,BC
	INC	HL		; ADD 1 TO HL TO THAT THE BYTE
	LD	(BYTCNT),HL	; COUNT IS THE DIFFERENCE BETWEEN
	LD	A,(BYTCNT+1)	; ENDADDR AND STADDR INCLUSIVE.
	OR	A		; SER FLAGS
	PUSH	AF
	CALL	CLDSP
	POP	AF
;
; THIS NEXT SECTION IS A CHECKING ROUTINE THAT WILL ENSURE THAT
; THE EPROM IS CLEAN. IF THE EPROM HAS BEEN PREVIOUSLY PROGRAMMED
; OR IT IS BAD, THE CHECKING ROUTINE WILL DISPLAY THOSE LOCATIONS
; IN THE EPROM THAT ARE INCORRECT. NOTE THAT IN A CLEAN EPROM
; ALL LOCATIONS WILL BE 'FF'. CARE MUST BE TAKEN IF THE USER WISHES
; TO PROGRAM A PREVIOUSLY PROGRAMMED LOCATION, IN THAT A BIT MAY
; BE CHANGED FROM A 1 TO A 0 BUT NOT VISE VERSA.
;
	JP	M,CDER		; BYTE COUNT MUST BE POSITIVE
	LD	BC,(BYTCNT)
	LD	HL,(DSTADD)
	LD	DE,(ENDADD)
;
; THIS NEXT SECTION IS THE DECODER. ITS PURPOSE IS TO ENSURE
; THAT ONLY THE SPECIFIED EPROMS ARE ENTERED AS THE DEVICE
; TO BE PROGRAMMED. IF IT IS FOUND THAT AN ILLEGAL DEVICE NUMBER
; HAS BEEN ENTERED, THEN IT WILL JUMP TO A ROUTINE (CDER) WHICH
; WILL GIVE AN ERROR PROMPT. OTHERWISE IT WILL BRANCH TO THE
; APPROPRIATE PROGRAMMING ROUTINE.
;
	CALL	CHECK
	LD	HL,(DEVICE)
	LD	A,L
	CP	8
	JR	NZ,PGM4
	LD	A,H
	CP	27H
	JP	NZ,CDER
	JP	PG1K

PGM4:
	CP	16H
	JR	NZ,PGM5
	LD	A,H
	CP	27H
	JP	NZ,CDER
	JP	PG2716

PGM5:
	CP	32H
	JP	NZ,CDER		; THE DECODER HAS EXHAUSTED THE DEVICE
	LD	A,H		; POSSIBILITIES AND JUMPS TO THE ERROR
	CP	27H		; ROUTINE. IN THE FUTURE, THE JUMP
	JP	Z,PG2732	; TO THE ERR ROUTINE WILL BE
	CP	25H		; REPLACED BY A JUMP TO DECODE
	JP	Z,PG2532	; OTHER POSSIBILITIES
	JP	CDER
;
; THE NEXT SECTION OF CODE IS THE ACTUAL PROGRAMMING PROCEDURE.
; IT IS SEPARATED INTO ITS PARTS BY DEVICE NUMBER, IE, THE
; CODE FOR PROGRAMMING A 2716 IS CALLED PG2716 ETC. EACH ROUTINE
; BEGINS ITS EXECUTION BY MAKING SURE THE PARAM'S (STADDR, ENDADD...
; ARE WITHIN APPROPRIATE LIMITS. AFTER THIS, IT OUTPUT THE ADDRESSES
; AND SETS THE PROGRAMMING CONTROL BITS, THEN OUTPUT THE DATA TO BE
; PROGRAMMED, CALLS A DELAY ROUTINE AND REPEATS BYTE-COUNT TIMES.
;
PG2716:
	LD	DE,(BYTCNT)
	LD	HL,0800H
	SBC	HL,DE
	JP	M,CDER
	LD	DE,(DSTADD)
	LD	HL,(STADDR)
	LD	BC,(BYTCNT)
PGM10:
	LD	A,D
	OR	00010000B
	OUT	(PGAH),A
	LD	A,E
	OUT	(PGAL),A
	LD	A,(HL)
	OUT	(PGD),A
	LD	A,D
	OR	00011000B
	OUT	(PGAH),A
	CALL	DELAY
	AND	00001111B
	OUT	(PGAH),A
	INC	DE
	CPI
	JP	PE,PGM10
	AND	00000111B
	OUT	(PGAH),A
	JP	PGM13

PG2532:
	LD	DE,(BYTCNT)
	LD	HL,1000H
	SBC	HL,DE
	JP	M,CDER
	LD	DE,(DSTADD)
	LD	HL,(STADDR)
	LD	BC,(BYTCNT)
P2532A:
	LD	A,D
	OR	00110000B	; SET UPPER TWO CONTROL BITS
	OUT	(PGAH),A	; IE, ENABLE INPUT DATA, AND
	LD	A,E		; SET CE = 1.
	OUT	(PGAL),A
	LD	A,(HL)
	OUT	(PGD),A
	LD	A,D
	OR	00100000B
	AND	00101111B	; RESET CE = 0
	OUT	(PGAH),A
	CALL	DELAY
	OR	00010000B	; SET CE = 1
	OUT	(PGAH),A
	INC	DE
	CPI
	JP	PE,P2532A
	AND	00011111B	; RESET DATA ENABLE BIT, BUT
	OUT	(PGAH),A	; DO NOT ENABLE EPROM UNTIL
	CALL	RDMSG
	JP	PGM13		; VPP IS REMOVED.

PG2732:
	LD	DE,(BYTCNT)
	LD	HL,1000H
	SBC	HL,DE
	JP	M,CDER
	LD	DE,(DSTADD)
	LD	HL,(STADDR)
	LD	BC,(BYTCNT)
P2732A:
	LD	A,D
	OR	00110000B	; OE = VPP, CE = 1
	OUT	(PGAH),A
	LD	A,E
	OUT	(PGAL),A
	LD	A,(HL)
	OUT	(PGD),A
	LD	A,D
	OR	00110000B
	AND	00011111B		; CE = 0, OE = VPP
	OUT	(PGAH),A
	CALL	DELAY
	AND	00011111B
	OUT	(PGAH),A
	INC	DE
	CPI
	JP	PE,P2732A
	AND	00000111B
	OUT	(PGAH),A
	JP	PGM13
;
; THIS ROUTINE IS A COMMON ROUTINE TO ALL THE ABOVE ROUTINES
; IT PROVIDES APPROXIMATELY 50MS. DELAY BEFORE RETURNING.
;
DELAY:
	PUSH	BC
	LD	B,50
LOOP:
	LD	C,0
LOOP1:
	DEC	C
	JR	NZ,LOOP1
	DJNZ	LOOP
	POP	BC
	RET
;
; CHECK IS A SUBROUTINE THAT MAKES SURE THE EPROM IS CLEAN, IE,
; EACH LOCATION IS A 'FF'.
;
CHECK:
	LD	BC,(BYTCNT)
CHECK1:
	LD	A,L
	OUT	(PGAL),A
	LD	A,H
	OUT	(PGAH),A
	IN	A,(PGD)
	CP	0FFH
	JP	NZ,NCLR
	CPI
	JP	PE,CHECK1
	RET

NCLR:
	PUSH	HL
	EX	DE,HL
	CALL	ADIS
NCLR1:
	CALL	DISP
	CP	ESC
	JP	Z,NCLR2
	CP	GO
	POP	HL
	RET	Z
	JR	NCLR1

NCLR2:
	INC	SP
	INC	SP		; FIX UP STACK
	POP	HL
	JP	CTST		; BACK TO CMD PROMPT

PGM13:
	LD	HL,(STADDR)	; THIS ROUTINE VERIFIES THAT
	LD	BC,(BYTCNT)	; THE DATA BURNT INTO THE EPROM
	LD	DE,(DSTADD)	; IS CORRECT.
PGM14:
	LD	A,D
	OUT	(PGAH),A
	LD	A,E
	OUT	(PGAL),A
	IN	A,(PGD)
	CP	(HL)
	CALL	NZ,EPMISM
	INC	DE
	CPI
	JP	PE,PGM14
	JP	MTD
;
; THIS IS A SPECIAL ROUTINE WHICH WILL PROGRAM A 2708.
; IT IS COMPLETELY SELF CONTAINED, EXCEPT FOR THE ACCESS
; TO THE GLOBAL PARAMETER STADDR, AND THE GLOBAL ROUTINE
; EPROM MISMTACH (EPMISM).
;
PG1K:
	LD	HL,(STADDR)	; CHK THAT EPROM IS ERASED
	XOR	A
	LD	E,A		; START AT ADDR 0
	LD	D,A
PGM16:
	OUT	(PGAH),A	; HI-BYTE
PGM17:
	LD	A,E
	OUT	(PGAL),A	; LO-BYTE
	IN	A,(PGD)		; READ EXISTING DATA VAL
	CP	0FFH
	JR	NZ,PGM24	; EPROM NOT ERASED
	INC	E
	JR	NZ,PGM17
	INC	D
	LD	A,D
	CP	4		; 0X0400 ?
	JR	NZ,PGM16	; NO: CHK NEXT ADDR
PGM26:
	LD	E,0		; # PROGRAMMING PULSES/BYTE
	LD	C,100		; 100 LOOPS THRU ALL ADDRS
	LD	HL,(STADDR)
PGM18:
	LD	D,00101100B	; ENABLE DATA AND SET CE = 12V (D3=1)
PGM19:				; D2 IS DON'T CARE, PROG (D4) = 0V
	LD	A,D
	OUT	(PGAH),A	; HI-BYTE OF ADDR
PGM20:
	LD	A,E
	OUT	(PGAL),A	; LO-BYTE OF ADDR
	LD	A,(HL)		; VAL TO BE PROGRAMMED
	OUT	(PGD),A
	INC	HL		; NEXT ADDR
	LD	A,D
	OR	00010000B	; SET PROG = 26V.
	CALL	DLY10
	OUT	(PGAH),A	; PGM BYTE
	LD	B,255		; 1MS PROGRAMMING PULSE
PGM21:
	DEC	B
	JR	NZ,PGM21
	AND	00101111B	; RESET PROG (D4) = 0.
	OUT	(PGAH),A
	INC	E
	JR	NZ,PGM20	; NEXT BYTE IN PAGE
	LD	A,D
	AND	00001111B
	INC	A
	INC	D
	CP	10H		; END OF EPROM (ADDR 0400 W CTRL BITS) ?
	JR	NZ,PGM19	; NO: NEXT 256 BYTE PAGE
	LD	HL,(STADDR)	; START ADDR AGAIN
	DEC	C		; FINISHED 100 LOOPS OF ALL ADDRS?
	JR	NZ,PGM18	; NO: NEXT LOOP
	LD	A,00000011B	; TURN OFF PROGRAMMING LEVELS
	OUT	(PGAH),A	; *** WAS 'OUT (PGAL),A' IN ORIGINAL CODE
	LD	HL,(STADDR)	; HL = SRC ADDR TO CHK AGAINST
	IN	A,(PGD)
	XOR	A
	LD	E,A		; DE = ADDR TO CHK
	LD	D,A
PGM22:
	OUT	(PGAH),A	; HI-BYTE OF ADDR
PGM23:
	LD	A,E
	OUT	(PGAL),A	; LO-BYTE OF ADDR
	IN	A,(PGD)
	CP	(HL)
	CALL	NZ,EPMISM	; BYTE NOT PROGRAMMED PROPERLY
	INC	HL
	INC	E
	JR	NZ,PGM23	; NEXT BYTE IN SAME PAGE
	INC	D		; NEXT PAGE
	LD	A,D
	CP	4		; 0400 (END OF EPROM) ?
	JR	NZ,PGM22	; NO: CHK NEXT BYTE
	JP	MTD		; EPROM OK: DISP DOUBLE PROMPT

PGM24:
	CALL	ADIS		; DIS-ASSEMBLE ADDR ON UNERASED BYTE
PGM25:
	CALL	DISP		; DISP IT
	CP	ESC
	JP	Z,CTST		; ESC ? ABORT EPROM PGM
	CP	GO
	JR	Z,PGM26		; GO ? PGM EPROM ANYWAY
	JR	PGM25		; IGNORE OTHER CMD'S

RDMSG:
	LD	HL,MDB0		; THIS ROUTINE PUTS THE
	LD	A,EQUALS	; MESSAGE S3=RD, ON THE DISPLAY
	LD	(HL),A		; SO THE USER CAN DISCONNECT
	INC	HL		; THE HIGH VOLTAGE BEFORE
	LD	A,BLANK		; READING THE EPROM
	LD	(HL),A
	INC	HL
	LD	A,3		; '3'
	LD	(HL),A
	INC	HL
	LD	A,5		; 'S'
	LD	(HL),A
	INC	HL
	LD	A,0DH		; 'D'
	LD	(HL),A
	INC	HL
	LD	A,CHRR		; 'R'
	LD	(HL),A
	CALL	DISP
	CP	GO
	RET	Z
	JR	RDMSG

DLY10:
	RET

EPMISM:
	CALL	ADIS		; THIS ROUTINE DISPLAY THE
	CALL	EPDIS		; INCORRECT CONTENTS OF THE
EMSM1:
	CALL	DISP		; EPROM OR ITS CORRECT
	CP	EM		; COUNTER-PART IN MEMORY. THE
	JR	Z,EPMISM	; ADDR OF THE INCORRECT LOCATION
	CP	EP		; IN EPROM IS IN DE, THE
	JR	Z,EMSM3		; CORRESPONDING ADDRESS OF THE
	CP	GO		; CORRECT DATA IN MEMORY IS IN HL
	RET	Z
	CP	ESC
	JR	Z,EMSM2
	JR	EMSM1

EMSM2:
	POP	BC		; FIX UP STACK
	JP	CTST		; BACK TO CMD PROMPT

EMSM3:
	EX	DE,HL
	CALL	ADIS
	CALL	DDIS
	EX	DE,HL
	JR	EMSM1

EPDIS:
	PUSH	HL		; THIS ROUTINE GETS THE CONTENTS
	PUSH	BC		; OF THE ADDRES IN DE FROM THE
	LD	A,D		; EPROM AND PUTS IT IN THE
	AND	00001111B	; DISPLAY BUFFER.
	OUT	(PGAH),A
	LD	A,E
	OUT	(PGAL),A
	IN	A,(PGD)
	LD	B,A		; SAVE DATA
	AND	0FH		; REMOVE UPPER NIBBLE AND STORE
	LD	HL,MDB4		; IT IN LS DISPLAY DIGIT
	LD	(HL),A
	INC	HL
	SRL	B		; GET MS NIBBLE OF DATA AND STORE
	SRL	B		; IT IN MS DATA DISPLAY DIGIT
	SRL	B
	SRL	B
	LD	(HL),B
	POP	BC
	POP	HL
	RET

	; ROUTINE TO DISP DOUBLE PROMPT

MTD:
	CALL	CLDSP
	LD	A,ULINE
	LD	(MDB0),A
	LD	(MDB1),A
MTD1:
	CALL	DISP
	CP	ESC		; WAIT FOR ESC KEY
	JP	Z,CTST
	JR	MTD1		; IGNORE ALL OTHERS

	; ROUTINE TO READ & WRITE I/O PORTS

STEIO:
	CALL	CLDSP		; DISPLAY 2 PROMPTS IN
	LD	A,ULINE		; ADDR MSD'S
	LD	HL,MDB3
	LD	(HL),A
	DEC	HL
	LD	(HL),A
	DEC	HL
	CALL	DISP
	CP	ESC
	JP	Z,CTST		; IF ESC, ABORT
	CP	GO
	JP	P,STEIO		; IGNORE ALL OTHER CMD'S
	LD	(HL),A		; GOT I/O PORT MSD
	DEC	HL
EIO1:
	CALL	DISP		; DISP IT
	CP	ESC
	JR	Z,STEIO		; IF ESC, RESTART THIS
	CP	GO
	JP	P,EIO1		; IGNORE ALL OTHER CMDS
	LD	(HL),A		; GOT I/O PORT LSD
EIO4:
	LD	HL,MDB1
	LD	A,(HL)		; PORT ADDR MSD
	ADD	A,A		; ASSEMBLE THE PORT ADDR
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A
	DEC	HL
	LD	A,(HL)		; LSD
	OR	C
	LD	C,A
	LD	HL,MDB5
	LD	A,ULINE
	LD	(HL),A		; DISP PROMPT IN DATA MSD
	DEC	HL
	LD	A,BLANK		; BLANK DATA LSD
	LD	(HL),A
EIO8:
	INC	HL
EIO2:
	CALL	DISP		; DISP IT
	CP	ESC
	JR	Z,STEIO		; IF ESC, RESTART THIS ROUTINE
	CP	EIO
	JR	Z,EIO5		; IF EIO, GO INCR PORT ADDR
	CP	EP
	JR	Z,EIO6		; IF EP, GO DECR PORT ADDR
	CP	ER
	JR	Z,EIO7		; IF ER, READ THE PORT
	CP	GO
	JP	P,EIO2		; IGNORE ALL OTHER CMD'S
	LD	(HL),A		; DATA KEY, MSD
	ADD	A,A
	ADD	A,A		; ASSEMBLE IT
	ADD	A,A
	ADD	A,A
	LD	B,A
	DEC	HL
EIO3:
	CALL	DISP		; DISP IT
	CP	ESC
	JR	Z,EIO4		; IF ESC, CLR FOR RETRY
	CP	GO
	JP	P,EIO3		; IGNORE OTHER CMD'S
	LD	(HL),A		; DATA KEY, LSD
	OR	B		; ASSEMBLE IT
	OUT	(C),A		; WRITE IT TO THE I/O PORT
	JR	EIO8		; WAIT FOR NEXT KEY

EIO5:
	LD	HL,MDB0
	LD	A,0FH
	INC	(HL)		; INCR PORT ADDR
	CP	(HL)
	JP	P,EIO4
	LD	(HL),0		; MODULO 256
	INC	HL
	INC	(HL)
	CP	(HL)
	JP	P,EIO4
	LD	(HL),0
	JR	EIO4

EIO6:
	LD	HL,MDB0
	DEC	(HL)		; DECR PORT ADDR
	JP	P,EIO4
	LD	(HL),0FH	; MODULO 256
	INC	HL
	DEC	(HL)
	JP	P,EIO4
	LD	(HL),0FH
	JR	EIO4

EIO7:
	IN	A,(C)		; READ THE PORT
	LD	B,A
	AND	0FH
	LD	HL,MDB4		; DIS-ASSEMBLE THE DATA
	LD	(HL),A		; INTO DISP BUF
	INC	HL
	SRL	B
	SRL	B
	SRL	B
	SRL	B
	LD	(HL),B
	JP	EIO2		; DISP IT

	; LED SEGMENT DEFINITION TABLE FOR CHARACTERS DISP'D
	
LSGTB:		;gfedcba
	DB	01000000B	; 0
	DB	01111001B	; 1
	DB	00100100B	; 2
	DB	00110000B	; 3
	DB	00011001B	; 4
	DB	00010010B	; 5
	DB	00000010B	; 6
	DB	01111000B	; 7
	DB	00000000B	; 8
	DB	00010000B	; 9
	DB	00001000B	; A
	DB	00000011B	; B
	DB	01000110B	; C
	DB	00100001B	; D
	DB	00000110B	; E
	DB	00001110B	; F
	DB	01110111B	; 10  (_)
	DB	01111111B	; 11  ( )
	DB	00110110B	; 12  ( ) ERR IND - 3 HORIZ LINES
	DB	00001001B	; 13  (H)
	DB	01000111B	; 14  (L)
	DB	00001100B	; 15  (P)
	DB	01011111B	; 16  (')
	DB	00011011B	; 17  (X)
	DB	00010001B	; 18  (Y)
	DB	00101111B	; 19  (R)
	DB	00001111B	; 1A  (|-)
	DB	00110111B	; 1B  (=)
	;	 gfedcba
	; KEY CODE TABLE

KEYCD:
	DB	00H	; 0
	DB	01H	; 1
	DB	02H	; 2
	DB	03H	; 3
	DB	EM	; EM
	DB	GO	; GO
	DB	SI	; SI
	DB	ESC	; ESC
	DB	04H	; 4
	DB	05H	; 5
	DB	06H	; 6
	DB	07H	; 7
	DB	EP	; EP
	DB	ER	; ER
	DB	BP	; BP
	DB	0FFH	; UNUSED
	DB	08H	; 8
	DB	09H	; 9
	DB	0AH	; A
	DB	0BH	; B
	DB	EIO	; EIO
	DB	CMP	; CMP
	DB	PGM	; PGM
	DB	0FFH	; UNUSED
	DB	0CH	; C
	DB	0DH	; D
	DB	0EH	; E
	DB	0FH	; F
	DB	MV	; MV
	DB	OFT	; OFT
	DB	LD	; LD
	DB	SV	; SV

	; ROUTINE TO CREATE A BREAK-POINT

STBP:
	XOR	A
	LD	(CBPNM),A	; CURRENT BRK-PT NUM = 0
BP0:
	CALL	CLDSP
BP1:
	LD	A,ULINE		; DISP PROMPT IN DATA MSD
	LD	(MDB5),A
BPE:
	LD	A,(CBPNM)
	LD	(MDB4),A	; DISP CUR BRK-PT NUM
	SLA	A
	SLA	A		; MULT BY 8
	SLA	A
	LD	IY,BPBA		; BRK-PT BASE ADDR
	LD	D,0
	LD	E,A
	ADD	IY,DE		; PTR TO CUR BRK-PT AREA
	LD	A,(IY+3)	; BRK-PT-DEFN'D FLAG
	OR	A
	JR	Z,BP3		; BRK-PT DEFINED ?
	LD	D,(IY+1)	; YES: GET ITS ADDR
	LD	E,(IY+0)
	CALL	ADIS		; DIS-ASSEMBLE IT
BP2:
	CALL	GETAD		; DISP IT & WAIT FOR CMD
	LD	B,A
	LD	A,C
	OR	A
	LD	A,B
	JR	NZ,BP4		; ANY DIGITS ENTERED ?
	CP	ESC		; YES
	JP	Z,CTST		; IF ESC, ABORT
	CP	BP
	JP	Z,NBP		; IF BP, EXAM NEXT BRK-PT
	CP	EP
	JP	Z,PBP		; IF EP, EXAM PREV BRK-PT
	CP	GO
	JP	Z,CLBP		; IF GO, CLR THIS BRK-PT
	CP	ER
	JP	Z,EDLN		; IF ER, EXAM ITS DELAY NUM
BP3:
	CALL	CLDSA		; CLR DISP ADDR DIGITS
	JR	BP2		; WAIT FOR CMD

BP4:
	CP	ESC
	JR	Z,BP3		; IF ESC, RESTART
BP5:
	CP	GO
	JR	Z,BP6		; IF GO, ENTER THE BRK-PT ADDR
	CALL	GETA1		; INTO TABLE
	JR	BP5		; IGNORE OTHER CMD'S

BP6:
	CALL	ADTR		; ASSEMBLE THE BRK-PT ADDR
	LD	(IY+1),D	; STORE IT IN TABLE
	LD	(IY+0),E
	LD	A,0FFH
	LD	(IY+3),A	; SET 'DEFINED' FLG
	JR	BP2		; GET NEXT BRK-PT

CLBP:
	LD	A,(IY+3)	; BRK-PT DEFINED FLG
	OR	A
	JR	Z,BP3		; IF NOT DEFN'D, CLR DISP
	XOR	A
	LD	(IY+3),A	; ELSE, CLR THE BRK-PT
	LD	L,(IY+0)	; BRK-PT ADDR
	LD	H,(IY+1)
	LD	A,(IY+2)	; SAVED PROG OP-CODE AT ADDR
	LD	(HL),A		; RESTORE IT
	XOR	A
	LD	(IY+0),A	; CLR OUT TBL ENTRY
	LD	(IY+1),A
	LD	(IY+4),A
	LD	(IY+5),A
	LD	(IY+6),A
	LD	(IY+7),A
	JP	BP3		; CLR DISP

EDLN:
	CALL	CLDSP
	LD	A,BPDLY		; PRK-PT DELAY SYMBOL
	LD	(MDB5),A	; DISP IT
	LD	A,(CBPNM)	; CUR BRK-PT NUM
	LD	(MDB4),A	; DISP IT
	LD	D,(IY+5)
	LD	E,(IY+4)	; BRK-PT DELAY NUM
	CALL	ADIS		; DIS-ASSEMBLE IT
EDL1:
	CALL	GETAD		; DISP IT & GET CMD
	LD	B,A
	LD	A,C
	OR	A
	LD	A,B
	JR	NZ,EDL3		; ANY DIGITS ENTERED ?
	CP	ESC		; NO
	JR	NZ,EDL2
	CALL	CLDSP		; IF ESC, RESTART
	LD	A,(CBPNM)	; CUR BRK-PT NUM
	LD	(MDB4),A	; DISP IT
	JP	BP1

EDL2:
	CALL	CLDSA		; CLR DISP ADDR DIGITS
	JR	EDL1		; RESTART DELAY NUM EXAM

EDL3:
	CP	ESC
	JR	Z,EDL2		; IF ESC, GO BACK & EXAM
EDL4:
	CP	GO
	JR	Z,EDL5		; IF GO, ENTER IT
	CALL	GETA1		; IGNORE OTHER CMD'S
	JR	EDL4

EDL5:
	CALL	ADTR		; ASSEMBLE THE DELAY NUM
	LD	(IY+5),D
	LD	(IY+4),E	; STORE IT IN TBL
	JP	BP0		; RESTART BRK-PT EXAM

NBP:
	LD	A,(CBPNM)	; CUR BRK-PT NUM
	INC	A
	LD	(CBPNM),A	; NEXT BRK-PT NUM
	CP	4
	JP	NZ,BPE		; MODULO 4
	XOR	A
	LD	(CBPNM),A
	JP	BPE

PBP:
	LD	A,(CBPNM)	; CUR BRK-PT NUM
	DEC	A
	LD	(CBPNM),A	; PREV BRK-PT NUM
	CP	0FFH
	JP	NZ,BPE		; MODULO 4
	LD	A,3
	LD	(CBPNM),A
	JP	BPE

	; ROUTINE TO CLEAR DISP ADDR DIGITS

CLDSA:
	LD	A,BLANK		; BLANK
	LD	B,4
	LD	HL,MDB0		; ADDR LSD
CLDA1:
	LD	(HL),A		; CLR IT
	INC	HL		; NEXT DIGIT
	DJNZ	CLDA1		; LAST DIGIT ?
	RET

	; ROUTINE TO SAVE REGISTERS OF PROGRAM AT INTERRUPT PT

SVREG:
	LD	SP,SREG		; START OF REG SAVE SPACE
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	EXX
	EX	AF,AF'
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	EXX
	EX	AF,AF'
	PUSH	IX
	PUSH	IY
	LD	A,I
	LD	(SV1),A
	LD	A,R
	LD	(SRR),A
	LD	SP,(SSPL)	; RESTORE SP
	POP	DE		; GET SAVED PC FROM STACK
	LD	(SPCL),DE	; SAVE IT IN MEM
	DEC	SP
	DEC	SP		; FIX UP STACK
	DEC	SP
	DEC	SP
	RET

	; ROUTINE TO REMOVE BREAK-POINTS FROM PROGRAM

RMBP:
	XOR	A
	LD	(BPF),A		; CLR BRK-PT'S-ACTIVE FLG
	LD	DE,8		; 8 BYTES / TBL ENTRY
	LD	IX,BPBA		; TBL BASE ADDR
	LD	B,4		; 4 BRK-PTS MAX
RMB1:
	LD	A,(IX+3)	; BRK-PT-DEFN'D FLG
	OR	A
	JR	Z,RMB2		; DEFINED ?
	LD	L,(IX+0)	; YES: GET ITS ADDR
	LD	H,(IX+1)
	LD	A,(IX+2)	; GET SAVED PROG OP-CODE
	LD	(HL),A		; RESTORE IT
RMB2:
	ADD	IX,DE		; CHK NEXT BRK-PT
	DJNZ	RMB1
	RET

	; BREAK-POINT INTERRUPT ROUTINE

BPINT:
	LD	(SSPL),SP	; SAVE SP
	CALL	SVREG		; SAVE REG'S
	LD	A,0FFH
	LD	(BPN),A		; SET BRK-PT-INTR FLG
	POP	HL		; SAVED PC
	DEC	HL
	LD	(SPCL),HL	; SAVE PC OF BRK-PT
	LD	BC,8		; 8 BYTE TBL AREA
	LD	IX,BPBA		; TBL BASE
BPI1:
	LD	A,(IX+3)	; BRK-PT-DEFN'D FLG
	OR	A
	JR	Z,BPI2		; DEFINED ?
	LD	A,(IX+0)	; YE
	CP	L
	JR	NZ,BPI2		; TBL ADDR MATCHES PC ?
	LD	A,(IX+1)
	CP	H
	JR	Z,BPI3
BPI2:
	ADD	IX,BC		; NO: CHK NEXT TBL ENTRY
	JR	BPI1

BPI3:
	LD	A,(IX+4)	; YES: GET DELAY NUM
	OR	A
	JR	NZ,BPI4
	LD	A,(IX+5)	; DELAY 0 ?
	OR	A
	JR	Z,BPI7
BPI4:
	LD	L,(IX+6)
	LD	H,(IX+7)	; NO: DECR DELAY CNTR
	DEC	HL
	LD	(IX+6),L
	LD	(IX+7),H
	LD	A,L
	OR	A
	JR	NZ,BPI5		; CNTR = 0 ?
	LD	A,H
	OR	A
	JR	Z,BPI6
BPI5:
	CALL	RMBP		; NO: REMOVE BRK-PT
	JP	CTCON		; GO TO CONTIN EXEC

BPI6:
	LD	L,(IX+4)	; YES: RE-INITIALIZE CNTR
	LD	H,(IX+5)
	LD	(IX+6),L
	LD	(IX+7),H
BPI7:
	CALL	RMBP		; REMOVE BRK-PTS
	JP	ERPC		; GO DISP PC & REG'S

	; ROUTINE TO SET BREAK-POINT INTERRUPT VECTOR

SBP:
	LD	A,0C3H		; "JP"
	LD	(RST8V),A
	LD	HL,BPINT
	LD	(RST8V+1),HL
	RET

	; ROUTINE TO INSERT BREAK-POINTS INTO PROGRAM

SUBP:
	CALL	SBP		; SET BRK-PT INTR VECT
	LD	A,0FFH
	LD	(BPF),A		; SET BRK-PT-ACTIVE FLG
	LD	DE,8		; 8 BYTE TBL AREA
	LD	IX,BPBA		; TBL BASE
	LD	B,4
SUBP1:
	LD	A,(IX+3)	; BRK-PT-DEF'D FLG
	OR	A
	JR	Z,SUBP2		; DEFINED ?
	LD	L,(IX+0)	; YES: GET ITS ADDR
	LD	H,(IX+1)
	LD	A,(HL)		; GET PROG OP-CODE AT BRK-PT
	LD	(IX+2),A	; SAVE IT IN TBL
	LD	A,0CFH		; "RST 08H" BRK-PT INTR CODE
	LD	(HL),A		; INSERT BRK-PT INTR INSTR
SUBP2:
	ADD	IX,DE		; CHK NEXT BRK-PT
	DJNZ	SUBP1
	RET

	; ROUTINE TO INITIALIZE BREAK-POINT DELAY COUNTERS

SUBD:
	LD	DE,8
	LD	IX,BPBA		; TBL BASE
	LD	B,4
SUBD1:
	LD	A,(IX+3)
	OR	A
	JR	Z,SUBD2		; BRK-PT DEFINED ?
	LD	L,(IX+4)	; YES: GET DELAY NUM
	LD	H,(IX+5)
	LD	(IX+6),L	; LOAD IT INTO CNTR
	LD	(IX+7),H
SUBD2:
	ADD	IX,DE		; CHK NEXT BRK-PT
	DJNZ	SUBD1
	RET

	; PROGRAM INTERRUPT ROUTINE (FROM NMI)

PRGI:
	LD	(SSPL),SP	; SAVE SP
	CALL	SVREG		; SAVE REG'S
	XOR	A
	LD	(BPN),A		; CLR BRK-PT-INTR FLG
	LD	A,(CTF)		; CONTIN FLG
	OR	A
	LD	A,0
	LD	(CTF),A		; CLR IT
	JP	NZ,CONTN	; GO CONTIN EXEC OF PROG
	LD	A,(BPF)		; BRK-PT'S-ACTIVE FLG
	OR	A
	JR	Z,PRGI1		; BRK-PT'S ACTIVE ?
	XOR	A
	LD	(BPF),A		; YES: CLR BRK-PT'S-ACTIVE FLG
	CALL	RMBP		; REMOVE BRK-PT'S
PRGI1:
	LD	A,01111111B
	OUT	(LSEG),A	; CLR ESC-INTR-ENABLE
PRGI2:
	CALL	KBDB		; KBD DEBOUNCE
	JR	NZ,PRGI2	; WAIT TIL KEY RELEASED
ERPC:
	LD	DE,(SPCL)	; GET SAVED PC
	CALL	ADIS		; DIS-ASSEMBLE IT
	LD	A,CHRP		; 'P'
	LD	(MDB5),A	; DISP 'PC'
	LD	A,0CH		; 'C'
	LD	(MDB4),A
ERDP:
	CALL	DISP		; DISP & GET CMD
	CP	GO
	JP	P,EROP		; IF CMD, DECODE IT
	CP	12+1
	JP	P,ERPC		; DISP PC
	CP	12
	JR	NZ,PRGI3
	XOR	A
	JR	PRGI4

PRGI3:
	INC	A		; SKIP OVER PC CODE
PRGI4:
	LD	(ERSC),A	; SAVE REG SEL CODE
ER1:
	LD	A,(ERSC)
	ADD	A,A		; MULT BY 2
	LD	D,0
	LD	E,A
	LD	HL,RCDTB	; REG CODE TBL
	ADD	HL,DE		; PTR TO REG CODE
	LD	A,(HL)		; GET THE CODE
	LD	(MDB5),A	; DISP IT IN DATA DIGITS
	INC	HL
	LD	A,(HL)
	LD	(MDB4),A
	LD	HL,SREG		; REG SAVE AREA BASE
	OR	A
	SBC	HL,DE		; PTR TO SELECTED REG
	LD	DE,MDB0
	EX	DE,HL
	LD	A,(DE)		; GET REG CONTENTS
	LD	B,A
	AND	0FH		; GET LO-BYTE
	LD	(HL),A		; DISP LSD
	INC	HL
	SRL	B		; GET NEXT DIGIT
	SRL	B
	SRL	B
	SRL	B
	LD	(HL),B		; DISP IT
	INC	HL
	INC	DE
	LD	A,(DE)		; GET HI-BYTE
	LD	B,A
	AND	0FH		; GET NEXT DIGIT
	LD	(HL),A		; DISP IT
	INC	HL
	SRL	B		; GET MSD
	SRL	B
	SRL	B
	SRL	B
	LD	(HL),B		; DISP IT
ER6:
	CALL	DISP		; DISP & GET CMD
	CP	GO
	JP	P,ER2		; CMD ?
	LD	HL,MDB3		; NO: DIGIT
	LD	(HL),A		; STORE MSD OF 1ST REG
	ADD	A,A
	ADD	A,A
	ADD	A,A		; ASSEMBLE MSD
	ADD	A,A
	DEC	HL
	LD	B,A
ER7:
	CALL	DISP		; DISP & GET LSD
	CP	GO
	JP	M,ER3		; CMD ?
	CP	ESC		; YES: IF ESC, EXAM THIS REG
	JR	Z,ER1		; PAIR AGAIN
	JR	ER7		; IGNORE OTHER CMD'S

ER3:
	LD	(HL),A		; DISP LSD
	OR	B		; ASSEMBLE BYTE
	LD	(DE),A		; STORE NEW REG DATA
ER8:
	CALL	DISP		; DISP IT & GET NEXT KEY
	CP	GO
	JP	M,ER4		; CMD ?
	CP	ESC		; YES: IF ESC, EXAM THIS REG
	JR	Z,ER1		; PAIR AGAIN
	JR	ER8		; IGNORE OTHER CMD'S

ER4:
	LD	HL,MDB1		; MSD OF 2ND DISP'D REG
	LD	(HL),A		; STORE MSD
	ADD	A,A
	ADD	A,A		; ASSEMBLE IT
	ADD	A,A
	ADD	A,A
	DEC	HL
	LD	B,A
ER9:
	CALL	DISP		; DISP IT & GET LSD
	CP	GO
	JP	M,ER5		; CMD ?
	CP	ESC		; YES: IF ESC, EXAM THIS REG
	JP	Z,ER1		; PAIR AGAIN
	JR	ER9		; IGNORE OTHER CMD'S

ER5:
	LD	(HL),A		; STORE LSD
	OR	B		; ASSEMBLT IT
	DEC	DE
	LD	(DE),A		; STORE NEW REG DATA
	INC	DE
	JP	ER1		; DISP AGAIN

ER2:
	JR	Z,ER8		; IF GO, SKIP CHANGING 1ST REG
	CP	ESC
	JP	Z,ERPC		; IF ESC, GO DISP PC
	CP	ER
	JR	Z,ER10		; IF ER, DISP NEXT REG PAIR
	CP	EP
	JR	Z,ER12		; IF EP, DISP PREV REG PAIR
	JR	ER6		; IGNORE OTHER CMD'S

ER10:
	LD	A,(ERSC)	; REG SEL CODE
	INC	A
	CP	12+1		; INCR MODULO 12
	JR	NZ,ER11
	XOR	A
ER11:
	LD	(ERSC),A	; NEXT SEL CODE
	JP	ER1		; GO DISP THE REG'S

ER12:
	LD	A,(ERSC)	; REG SEL CODE
	DEC	A
	CP	0FFH		; DECR MODULO 12
	JR	NZ,ER13
	LD	A,12
ER13:
	LD	(ERSC),A	; NEXT SEL CODE
	JP	ER1		; DISP THE REG'S

EROP:
	JP	Z,CTCON		; IF GO, CONTIN EXEC
	CP	ESC
	JP	Z,CTST		; IF ESC, ABORT
	CP	SI
	JP	Z,CTSI		; IF SI, EXEC SINGLE INSTR
	JP	ERDP		; IGNORE OTHER CMD'S

	; LED SEGMENT DEFINITION TABLE FOR REG NAMES DISP'D
	
RCDTB:
	DB	CHRP	; P
	DB	0CH	; C
	DB	0AH	; A
	DB	0FH	; F
	DB	0BH	; B
	DB	0CH	; C
	DB	0DH	; D
	DB	0EH	; E
	DB	CHRH	; H
	DB	CHRL	; L
	DB	0AH	; A
	DB	APOSTR	; '
	DB	0BH	; B
	DB	APOSTR	; '
	DB	0DH	; D
	DB	APOSTR	; '
	DB	CHRH	; H
	DB	APOSTR	; '
	DB	1	; I
	DB	CHRX	; X
	DB	1	; I
	DB	CHRY	; Y
	DB	1	; I
	DB	CHRR	; R
	DB	5	; S
	DB	CHRP	; P

	; ROUTINE TO START EXECUTION OF A PROGRAM

START:
	CALL	SUBD		; INITIALIZE BRK-PT DELAY
	CALL	SUBP		; INSERT BRK-PT'S
	CALL	ADTR		; ASSEMBLE START ADDR
	CALL	SENMI		; SET NMI INTR VECT
	EX	DE,HL		; GET START ADDR
	JP	(HL)		; JUMP TO IT

	; ROUTINE TO SET NMI INTERRUPT VECTOR

SENMI:
	CALL	CLDSP
	LD	A,0C3H		; "JP"
	LD	(NMIV),A
	LD	HL,PRGI
	LD	(NMIV+1),HL
	LD	A,11111111B
	OUT	(LSEG),A	; SET EN-ESC-INTR
	LD	A,00000001B	; SEL ESC KEY
	OUT	(MLED),A
	RET

	; ROUTINE TO CONTINUE EXECUTION OF A PROGRAM

CONTN:
	LD	A,(SPCL)	; GET SAVED PC
	OR	A
	JR	NZ,CNTN2	; IS IT VALID ?
	LD	A,(SPCH)
	OR	A
	JP	Z,CTST		; NO: ABORT
CNTN2:
	CALL	SUBP		; INSERT BRK-PT'S
	CALL	SENMI		; SET NMI INTR VECT
CNTN1:
	LD	DE,(SPCL)	; GET SAVED PC
	PUSH	DE		; SAVE IT AS RET ADDR ON STACK
	LD	SP,ESREG	; END OF SAVED REG AREA
	LD	A,(SVI)
	LD	I,A
	LD	A,(SRR)
	LD	R,A
	POP	IY		; RESTORE ALL REG'S
	POP	IX
	EXX
	EX	AF,AF'
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	EXX
	EX	AF,AF'
	POP	HL
	POP	DE
	POP	BC
	LD	A,(BPN)		; BRK-PT INTR ?
	OR	A
	JR	Z,CNTN3
	POP	AF		; YES: RESTORE AF
	LD	SP,(SSPL)	; RESTORE SP
	RET			; CONTIN EXEC OF PROG

CNTN3:
	POP	AF
	LD	SP,(SSPL)
	RETN			; CONTIN EXEC OF INTR'D PROG

	; ROUTIN TO EXAM REGISTERS

STER:
	LD	A,(SPCL)	; GET SAVE PC
	OR	A
	JR	NZ,STER1	; IS IT VALID ?
	LD	A,(SPCH)
	OR	A
	JP	Z,CTST		; NO: ABORT
STER1:
	JP	ERPC		; YES: GO EXAM IT

	; ROUTINE TO START EXECUTING A SINGLE INSTRUCTION

STSI:
	CALL	ADTR		; ASSEMBLE START ADDR
	CALL	CLDSP
	PUSH	DE		; SAVE IT AS RET ADDR ON STACK
	LD	A,01000000B	; SING INSTR ACTIVATION CODE
	PUSH	AF		; SET UP STACK
	OUT	(MLED),A	; START SING INSTR CNTR
	POP	AF		; RESTORE STACK
	NOP			; ANOTHER CNT
	RET			; GO EXEC A SING INSTR

	; ROUTINE TO CONTINUE EXECUTING NEXT SINGLE INSTRUCTION

CTCON:
	LD	A,0FFH
	LD	(CTF),A		; SET CONTIN FLG
CTSI:
	LD	A,(SPCL)	; GET SAVED PC
	OR	A
	JR	NZ,CTSI1	; IS PC VALID ?
	LD	A,(SPCH)
	OR	A
	JP	Z,CTST		; NO: ABORT
CTSI1:
	LD	DE,(SPCL)	; GET SAVED PC
	PUSH	DE		; SAVE IT AS RET ADDR ON STACK
	LD	SP,ESREG	; END OF SAVED REG AREA
	LD	A,(SVI)
	LD	I,A
	LD	A,(SRR)
	LD	R,A
	POP	IY		; RESTORE ALL REG'S
	POP	IX
	EXX
	EX	AF,AF'
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	EXX
	EX	AF,AF'
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	LD	SP,(SSPL)	; RESTORE SP
	PUSH	AF		; SAVE AF
	LD	A,01000000B	; SING INSTR ACTIVATION CODE
	OUT	(MLED),A	; START SING INSTR CNTR
	POP	AF		; RESTORE AF
	RETN			; GO EXEC A SING INSTR

	; ROUTINE TO LOAD INTO MEMORY FROM CASSETTE

LDCT:
	CALL	CLDSP
LD1:
	IN	A,(PGAH)	; READ CASSETTE SIGNAL
	BIT	7,A
	JR	NZ,LD1		; WAIT FOR FALLING EDGE
LD2:
	IN	A,(PGAH)
	BIT	7,A
	JR	Z,LD2		; WAIT FOR RISING EDGE
	LD	B,60H
LD3:
	DJNZ	LD3		; DELAY TO 3/4 OF BIT CELL (FM)
	IN	A,(PGAH)
	BIT	7,A
	JR	Z,LD6		; IS THE BIT A '1' ?
LD4:
	IN	A,(PGAH)	; NO
	BIT	7,A
	JR	NZ,LD4		; WAIT FOR FALLING EDGE
	LD	B,60H
LD5:
	DJNZ	LD5		; 3/4 BIT CELL DELAY
	IN	A,(PGAH)
	BIT	7,A
	JR	Z,LD2		; IS THE BIT A '0' ?
LD6:
	LD	HL,SAL		; NO: FOUND HEADER ON TAPE
	LD	B,4
	LD	A,1		; INITIALIZE CHECK-SUM
LD7:
	CALL	BTS		; ASSEMBLE BYTE FROM TAPE
	LD	(HL),A		; STORE NEXT HEADER BYTE
	LD	E,A
	EX	AF,AF'
	ADD	A,E		; ADD IT TO CHECK-SUM
	INC	HL
	DJNZ	LD7		; END OF HEADER ?
	LD	HL,(SAL)	; YES: GET SAVED ADDR
	LD	BC,(BCL)	; GET SAVED BYTE-CNT
LD8:
	CALL	BTS		; ASSEMBLE NEXT DATA BYTE
	LD	(HL),A		; STORE IT IN MEM
	LD	E,A
	EX	AF,AF'
	ADD	A,E		; ADD IT TO CHECK-SUM
	CPI			; DECR BYTE-CNT
	JP	PE,LD8		; END OF DATA ?
	CALL	BTS		; YES: ASSEMBLE CHECK-SUM
	LD	E,A		; FROM TAPE
	EX	AF,AF'
	ADD	A,E		; ADD IT TO CALC'D CHECK-SUM
	JR	Z,LD9		; CHECK-SUM ERROR ?
	LD	A,ERR		; YES
	LD	(MDB5),A	; DISP TRIPLE BAR ERR IND
	JP	CTST1		; ABORT

LD9:
	LD	DE,(SAL)	; GET SAVED ADDR
	CALL	ADIS		; DIS-ASSEMBLE IT INTO DISP BUF
	JP	STEM		; GO TO EXAM-MEM ROUTINE

	; ROUTINE TO WRITE MEMORY BLOCK ONTO CASSETTE

STSV:
	CALL	ADTR		; ASSEMBLE START ADDR
	PUSH	DE		; SAVE IT
	LD	DE,MDB5		; TO DISP PROMPT IN DATA LSD
	CALL	ADCOM		; DECODE NXT KEY CMD
	CP	ESC
	JR	NZ,SV5		; ESC CMD ?
	POP	DE		; YES: RESTORE STACK
	JP	CTST		; GO BACK TO CMD PROMPT

SV5:
	CALL	ADTR		; ASSEMBLE END ADDR
	CALL	CLDSP
	LD	H,D
	LD	L,E		; END ADDR
	POP	BC		; START ADDR
	LD	(SAL),BC	; SAVE START ADDR
	OR	A
	SBC	HL,BC		; CALC BYTE CNT
	INC	HL
	LD	(BCL),HL	; SAVE IT
	LD	A,1		; PREAMBLE SYNC BYTE
	LD	(PRE),A		; SAVE IT
	XOR	A
	OUT	(MLED),A	; DISABLE DISP DIGITS
	LD	A,00111111B
	OUT	(LSEG),A	; CLR CASSETTE SINE-WAVE
	LD	A,11111111B	; GEN CNTR
	OUT	(LSEG),A
	LD	B,3
	XOR	A
SV1:
	OUT	(PGAH),A	; STEP IT 3 TIMES TO REACH
	DJNZ	SV1		; 0-CROSSING
	EX	AF,AF'
	XOR	A
	EX	AF,AF'
	XOR	A		; CLR CHECK-SUM
	LD	BC,0800H	; SEND OUT 2K BYTES OF 0'S
SV2:
	LD	E,0		; (8 SEC PRE-AMBLE)
	CALL	BSH
	CPI
	JP	PE,SV2		; END OF PRE-AMBLE ?
	LD	B,5		; YES
	LD	HL,PRE		; SEND OUT HEADER
SV3:
	LD	E,(HL)
	CALL	BSH
	INC	HL
	DJNZ	SV3		; END OF HEADER ?
	LD	HL,(SAL)	; YES: GET START ADDR
	LD	BC,(BCL)	; GET BYTE-CNT
SV4:
	LD	E,(HL)		; GET NEXT DATA BYTE
	CALL	BSH		; SEND IT OUT
	CPI			; DECR BYTE-CNT
	JP	PE,SV4		; END OF DATA ?
	NEG			; YES: COMPL. CHECK-SUM
	LD	E,A
	CALL	BSH		; SEND IT OUT
	LD	E,0
	CALL	BSH		; SEND OUT 2 0-BYTES
	LD	E,0
	CALL	BSH
	JP	CTST		; GO BACK TO CMD PROMPT

	; ROUTINE TO DECODE & ASSEMBLE A BYTE FROM CASSETTE

BTS:
	EXX
	EX	AF,AF'
	LD	D,8		; BIT CNT
BTS1:
	IN	A,(PGAH)	; READ CASSETTE SIGNAL
	BIT	7,A
	JR	NZ,BTS4
BTS2:
	IN	A,(PGAH)
	BIT	7,A
	JR	Z,BTS2		; WAIT FOR RISING EDGE
	LD	B,60H
BTS3:
	DJNZ	BTS3		; 3/4 BIT CELL DELAY
	IN	A,(PGAH)	; READ THE BIT FROM CASSETTE
	CPL			; IT IS INVERTED HERE
	JR	BTS6

BTS4:
	IN	A,(PGAH)
	BIT	7,A
	JR	NZ,BTS4		; WAIT FOR FALLING EDGE
	LD	B,60H
BTS5:
	DJNZ	BTS5		; 3/4 BIT CELL DELAY
	IN	A,(PGAH)	; RD THE BIT FROM CASSETTE
BTS6:
	RL	A
	RL	E		; SHIFT IT IN (MSB IS 1ST)
	DEC	D
	JR	NZ,BTS1		; LAST BIT ?
	LD	A,E		; YES
	EXX
	RET

	; ROUTINE TO DIS-ASSEMBLE BYTE, ENCODE IT (FM) AND
	; SHIFT IT OUT TO CASSETTE AS SINE-WAVE

BSH:
	ADD	A,E		; ADD BYTE TO CHECK-SUM
	EX	AF,AF'
	LD	D,9		; BIT CNTR
BSH1:
	DEC	D
	JR	NZ,BSH2		; LAST BIT ?
	EX	AF,AF'		; YES
	RET

BSH2:
	SLA	E		; SHIFT NEXT DATA BIT (MSB 1ST)
	JR	NC,BSH5		; 0-BIT ?
	EXX			; NO
	LD	C,16		; 16 STEP = 1 FULL SINE-WAVE
BSH3:
	LD	B,6		; CYCLE OF 500 US (2 KHZ)
BSH4:
	DJNZ	BSH4		; 31 US DELAY
	OUT	(PGAH),A	; NEXT CNTR STEP OF SINE-WAVE
	DEC	C
	NOP
	JR	NZ,BSH3		; END OF CYCLE ?
	EXX			; YES: END OF BIT
	JR	BSH1

BSH5:
	EXX
	LD	C,8		; 8 STEPS = 1/2 SINE-WAVE CYCLE
BSH6:
	LD	B,16		; OF 500 US (1KHZ)
BSH7:
	DJNZ	BSH7		; 62.5 US DELAY
	OUT	(PGAH),A	; NEXT CNTR STEP OF SINE-WAVE
	DEC	C
	JR	NZ,BSH6		; END OF HALF-CYCLE ?
	EXX			; YES: END OF BIT
	JR	BSH1

	DS	0FD00H-$	; TO REACH ADDR 0FD00H

	; CASSETTE CALIBRATION PROGRAM
	
CALTX:
	CALL	CLDSP
	XOR	A		; INITIALIZE
	OUT	(MLED),A	; DISABLE DISP DIGITS
	LD	A,00111111B
	OUT	(LSEG),A	; CLR CASSETTE SINE-WAVE
	LD	A,11111111B	; GEN CNTR
	OUT	(LSEG),A
	LD	B,3
	XOR	A
CALT1:
	OUT	(PGAH),A	; STEP IT 3 TIMES TO REACH
	DJNZ	CALT1		; 0-CROSSING
	EX	AF,AF'
	XOR	A
	EX	AF,AF'
CALT2:
	LD	E,0
	CALL	BSH		; SEND OUT 0-BYTES
	JR	CALT2

	DS	0FD20H-$

	; CALIBRATION READBACK ROUTINE

CALRX:
	CALL	CLDSP
	LD	A,01001111B	; VERT BAR SYMB
	OUT	(LSEG),A
CALR1:
	LD	B,0		; PULSE-WIDTH CNTR
CALR2:
	IN	A,(PGAH)	; READ CASSETTE SIGNAL
	BIT	7,A
	JR	Z,CALR2		; WAIT FOR RISING EDGE
CALR3:
	INC	B		; COUNT WIDTH OF PULSE
	IN	A,(PGAH)
	BIT	7,A
	JR	NZ,CALR3
	LD	A,B		; GET PULSE-WIDTH CNT
	CP	32H		; CALC DEVIATION FROM
	JP	M,DLT		; CORRECT WIDTH
	CP	37H
	JP	M,DLT1
	CP	41H
	JP	P,DRT
	CP	3CH
	JP	P,DRT1
	LD	A,00000001B	; A0 - CORRECT (BAR CENTERED)
	JR	CALR4

DLT:
	LD	A,00001000B	; A3
	JR	CALR4

DLT1:
	LD	A,00000100B	; A2
	JR	CALR4

DRT:
	LD	A,00010000B	; D0
	JR	CALR4

DRT1:
	LD	A,00100000B	; D1
CALR4:
	OUT	(MLED),A
	JR	CALR1

	DS	38*16

	REPT	0000H-$
	DB	0FFH
	ENDM

	.DEPHASE
	
	END
